目录文档：[MySQL 源码｜源码剖析文档目录](https://zhuanlan.zhihu.com/p/714761054)

源码位置（版本 = MySQL 8.0.37）：[sql/sql_yacc.yy](https://github.com/mysql/mysql-server/blob/trunk/sql/sql_yacc.yy)；[sql/sql_lex.cc](https://github.com/mysql/mysql-server/blob/trunk/sql/sql_lex.cc)；[sql/parser_yystype.h](https://github.com/mysql/mysql-server/blob/trunk/sql/parser_yystype.h)

---

MySQL 使用 Bison 语法解析器实现 SQL 语句的解析功能。Bison 解析器的核心逻辑如下：

- Bison 语法文件
- `yylex()` 函数：用于实现词法解析器的功能，将输入流识别为 Token 并将它们返回给解析器
- `yyparse()` 函数：语法解析器的入口函数，该函数由 Bison 解析器生成，用于运行执行解析过程

#### Bison 语法文件

> 关于 MySQL 的 Bison 语法文件中用到的 Bison 语法，详见 [MySQL 源码｜33 - 语法解析：bison 基础语法规则](https://zhuanlan.zhihu.com/p/714779214)。

在 MySQL 的源码中，Bison 的语法文件为 [sql/sql_yacc.yy](https://github.com/mysql/mysql-server/blob/trunk/sql/sql_yacc.yy)，其中主要包含如下三部分：

- Bison 声明
- 终结符、语义组的返回值类型
- 语义组的备选规则及行为

其中返回值类型与语义组的逻辑，我们会在梳理语法解析逻辑时根据语法顺序梳理，现在先来看一下其中的 Bison 声明。

- 使用 `%start` 声明了语法解析的入口为 `start_entry` 语义组：

```C++
%start start_entry
```

- 使用 `%parse-param` 声明了 `yyparse()` 函数的两个参数，分别是 `THD` 类型的 `YYTHD` 用于提供当前运行环境的上下文，以及 `Parse_tree_root` 类型的 `parse_tree` 指针指向解析树的根节点。

```C++
%parse-param { class THD *YYTHD }
%parse-param { class Parse_tree_root **parse_tree }
```

- 使用 `%lex-param` 声明了 `yylex()` 函数的一个参数，即 `THD` 类型的 `YYTHE` 用于提供当前运行环境的上下文：

```C++
%lex-param { class THD *YYTHD }
```

- 使用 `%define api.pure` 指定了 Bison 构造一个纯净的（pure），可重入的（reentrant）解析器，从而支持多线程的场景，但同时也令全局通信变量 `yylval` 和 `yylloc` 被替换为 `yyparse()` 函数的两个参数。

```C++
%define api.pure                                    /* We have threads */
```

- 使用 `%define api.prefix` 指定了主要函数和宏指令的前缀，将 `yy` 前缀改为了 `my_sql_parser_` 前缀，将 `YY` 前缀改为 `MY_SQL_PARSER_` 前缀：

```C++
%define api.prefix {my_sql_parser_}
```

> 关于前缀设置逻辑，详见 [Bison 官方文档 - 3.8 Multiple Parsers in the Same Program](https://www.gnu.org/software/bison/manual/bison.html#Multiple-Parsers) 和 [MySQL 源码｜62 - 词法解析(V2)：调用词法解析器的逻辑](https://zhuanlan.zhihu.com/p/716898493)。

#### `yylex()` 函数（词法解析入口）

因为在 Bison 语法文件中定义了 `%define api.prefix {my_sql_parser_}`，所以 MySQL 的 `yylex()` 函数即 `my_sql_parser_lex()` 函数。该函数在 [sql/sql_lex.cc](https://github.com/mysql/mysql-server/blob/trunk/sql/sql_lex.cc) 中定义，用于实现词法解析器的功能，将输入流识别为 Token 并将它们返回给解析器。

函数签名如下：

```C++
int my_sql_parser_lex(MY_SQL_PARSER_STYPE *yacc_yylval, POS *yylloc, THD *thd)
```

因为在 Bison 语法文件中定义了 `%define api.pure`，所以 `my_sql_parser_lex()` 函数额外包含 `MY_SQL_PARSER_STYPE` 类型的参数 `yacc_yylval`（即 `yylval`），`POS` 类型的参数 `yylloc`（即 `yylloc`）。

其中 `MY_SQL_PARSER_STYPE` 即修改前缀后的 `YYSTYPE` 联合体，该联合体用于指定终结符和语义组的返回值类型。`MY_SQL_PARSER_STYPE` 结构体在 [sql/parser_yystype.h](https://github.com/mysql/mysql-server/blob/trunk/sql/parser_yystype.h) 中被定义。

其中 `POS` 类型为结构体 `MY_SQL_PARSER_LTYPE` 的别名，即修改前缀后的 `YYLTYPE` 联合体，其中的 `cpp` 成员用于存储 Token 在预处理流中的位置，`raw` 用于存储 Token 在原始流中的位置，源码如下：

```C++
struct MY_SQL_PARSER_LTYPE {
  Symbol_location cpp;  // token location in the preprocessed buffer
  Symbol_location raw;  // token location in the raw buffer

  bool is_empty() const { return cpp.is_empty(); }
};
```

其中 `Symbol_location` 为结构体，包括 `start` 和 `end` 两个指针成员，分别指向 Token 的第 1 个字节和 Token 结束后的下 1 个字节。

> 关于 Bison 语法中 `yylex()` 函数的逻辑，详见 [Bison｜4.3 词法分析器函数 yylex](https://zhuanlan.zhihu.com/p/720382621)。

#### `yyparse()` 函数（语法解析器入口）

因为在 Bison 语法文件中定义了 `%define api.prefix {my_sql_parser_}`，所以 MySQL 的 `yyparse()` 函数即 `my_sql_parser_parse()` 函数。函数则作为语法解析器的对外接口，调用该函数即可执行解析过程。

该函数仅在 [sql/sql_class.cc](https://github.com/mysql/mysql-server/blob/trunk/sql/sql_class.cc) 中的 `THE::sql_parser()` 函数中被调用。源码如下：

```C++
/**
  Call parser to transform statement into a parse tree.
  Then, transform the parse tree further into an AST, ready for resolving.
*/
bool THD::sql_parser() {
  /*
    SQL parser function generated by YACC from sql_yacc.yy.

    In the case of success returns 0, and THD::is_error() is false.
    Otherwise returns 1, or THD::>is_error() is true.

    The second (output) parameter "root" returns the new parse tree.
    It is undefined (unchanged) on error. If "root" is NULL on success,
    then the parser has already called lex->make_sql_cmd() internally.
  */
  extern int my_sql_parser_parse(class THD * thd,
                                 class Parse_tree_root * *root);

  Parse_tree_root *root = nullptr;
  if (my_sql_parser_parse(this, &root) || is_error()) {
    /*
      Restore the original LEX if it was replaced when parsing
      a stored procedure. We must ensure that a parsing error
      does not leave any side effects in the THD.
    */
    cleanup_after_parse_error();
    return true;
  }
  if (root != nullptr && lex->make_sql_cmd(root)) {
    return true;
  }
  return false;
}
```

`my_sql_parser_parse()` 函数有两个参数，均为在 Bison 语法中声明的。如果解析成功，则第二个参数 `parse_tree` 指向的将成为一个新的解析树；如果解析失败，则不会构造解析树。如果 `root` 参数为 `nullptr` 且解析成功，则说明解析器已经在内部调用了 `lex->make_sql_cmd()` 函数：

```C++
%parse-param { class THD *YYTHD }
%parse-param { class Parse_tree_root **parse_tree }
```

在调用时，如果 `my_sql_parser_parse()` 函数返回失败，则调用 `cleanup_after_parse_error()` 函数清理解析信息并返回 `true`；如果 `my_sql_parser_parse()` 函数返回成功，则根据解析树是否为空决定是否调用 `lex->make_sql_cmd()` 函数，并根据 `lex->make_sql_cmd()` 函数的返回值返回。

> 关于 Bison 语法中 `yyparse()` 函数的逻辑，详见 [Bison｜4.1 解析函数 yyparse](https://zhuanlan.zhihu.com/p/720431034)。
